git 操作まとめ。
-----------------------------------------------------------------------------------------------------------------------------
    (1) 新規プロジェクト作成
-----------------------------------------------------------------------------------------------------------------------------
    ＜ローカル＞
        ・すでにあるプロジェクトのあるルートにて、git init    :   gitのローカルリポジトリが出来る。
        ・.gitignoreファイルをルートに置く。                :   余計なファイルをコミットしないため。
        ・git add .                                       :  ステージング、
        ・git commit -m"firstcommit"                      :   コミット 

            ※コミットする前は、ブランチが存在しない。（git branchをしても何も表示されない。）
                 → 一番はじめのgit commitをするときに、デフォルトブランチが自動的に作られる。

       ・ git branchで確認する。もし[master]というブランチが作られている場合、リモートのデフォルト「main」と異なるため、合わせる必要がある。
                →    git branch -m master main  を行う      ：ブランチ名がmainになる。
        ※この時点でローカルリポジトリmainに、最初のコード状態が記録された状態になった。
        まだリモートリポジトリの設定がされてない状態。

    <リモート>
        ・gitlabで、新しいプロジェクトを作る。
            ※ここで、READMEを作らない方がよかった（READMEのコミットが行われてしまい、ローカルと差分が出来てしまう）
            ※→pushしようとするとエラーになる。git pull --rebaseをすれば大丈夫（後述）
        ・出来たら、トップ画面で「コード」→「HTTPでクローン」のところのコピーボタンを押す。（URLがコピーされる）
    ＜ローカル＞
        ・git remote add origin <コピーしたURL>     ：  ローカルの中の、リモートリポジトリ情報（originという名前）の登録
            （確認）
                ・git remote            :   リモートリポジトリの一覧
                ・git remote get-url origin: originに登録されているリモートリポジトリのURL

             (変更したい場合)
                ・git remote set-url origin [新しいURL]

         ・プッシュする
            git push -u origin main : -uをつけることで次回以降はoriginを指示しなくてもよくなる。

            成功すればOK
origin
        ・失敗したら：自分は　Updates ware rejected because the remote contains work that you do not have locally.
                    がでた。リモートの内容がローカルにないという意味。
            git pull --rebase origin main   :   pull : リモートの内容とローカルの内容をマージして一致させる。
                                                --rebaseをつけると、リモートのコミットの後に、ローカルのコミットされた、という履歴の順番になる。
                                                →   ベースをremoteからpullしてきたものとして、現状のコミット状態を作るという意味になる。

                                                つけないと逆になる。結果としては同じだが、コミットの時系列を整えるために
                                                これをつける必要があるらしい。

            git push -u origin main         :   改めてこの状態をプッシュする。
            ※この処理が面倒なので、次回からはリモートはreadmeを作らないようにする。




-----------------------------------------------------------------------------------------------------------------------------
    (1) ローカルからリモートへのプッシュについて
-----------------------------------------------------------------------------------------------------------------------------
・ルートディレクトリに.gitignoreファイルを用意し、git管理しない拡張子の登録をする。
     ※サブディレクトリに.gitignoreがあると、それ以下のものはその内容で上書きされてしまう。

・vscodeで編集する。
・git add . : 変更内容をステージング。（コミットの前の段階）にする。
・git commit  -m 'message' : ステージングされた変更内容をローカルリポジトリに記録する。
                             messageで内容を記述する。
・git push origin <branch名> : ローカルのコミット内容をリモートにアップロードする。

    →これらはvscode上でボタン操作でできる。

-----------------------------------------------------------------------------------------------------------------------------
    (2) ローカルでの作業が終わり、mainに内容をマージする。
-----------------------------------------------------------------------------------------------------------------------------

    ・gitlabに行き、該当のブランチを選択する。
    ・マージリクエストを作成する。ボタンを押す。
    ・（本来は、マージする権限をもった人しかできない）
        マージリクエスト（タブ）を選択すると、マージリクエストが届いている。
        内容を確認して、マージボタンを押す。その際、マージ元のブランチを消すかどうか選択できる。
        通常、ブランチを消してしまう。消えるが、履歴にはのこっているようだ？
    ・リモートリポジトリ上ではmainに変更内容が統合され、元のブランチが消える。
-----------------------------------------------------------------------------------------------------------------------------
    (3) ローカルをリモートの状態に合わせる
-----------------------------------------------------------------------------------------------------------------------------
       ※ 以下作業は「git cmd」を起動して行う。通常のコマンドプロンプトでもいいと思うが
    ・（２）の時点で、リモートと、ローカルの状態は変わっている。

    ・まずマージ先のmainブランチをリモートに合わせる。（そのほうがいいと思う）
        !pullと同じなので必要がない
        !   git fetch origin   : origin(リモートリポジトリ)の変更履歴をダウンロードする。
        !                       ※ファイル内容は変更されず、git内部の履歴が最新のもの
        !                       （最終マージなど、リモートにしかないような履歴があるため、ローカルも合わせる）

        git switch main     :mainにローカルブランチを切り替える。
        git reset --hard    :（もしmainが変更されていたりステージされていたりすると、この先の操作でエラーになるので）
                             mainブランチの状態を最新コミットの状態にする。
                             ※ローカルでmainにコミットすることはないと思うが、もし必要ならコミット＆プッシュする。
                             ※やったことはないが一時退避のstashという操作もあるらしい。

			※	reset は、ローカルにあるブランチの履歴を一つまきもどすコマンド。
					オプションなし	：	単純に一つ前の履歴をHEADが指し示す。
					--mixed			：	ステージングエリアも一つ前のコミットに書き換える（もしaddしている場合は、ステージングが取り消される）
										作業中のファイルは変更されない。
					--hard			：	--mixedの処理に加えて、作業中のファイル内容も書き換わる。

			※	この処理は、もしmainブランチに、ローカル独自で何かコミットをしてしまっている場合、リモートからpullするするときに不整合が出てしまうため、
				確実にリモートの履歴に存在する履歴状態に戻すという意味でこの処理を行っている。
				（gitのツリーについては一番下の説明とWEBサイトの情報を参照）

        git pull origin main :  git fetch origin(最新履歴の取得) + git merge origin/main(origin/main(リモートリポジトリのmainブランチ)
                                最新コミットを、選択中のローカルブランチへ反映させる)

    ・ローカルに残っている、古いブランチを削除
        git branch -d (作業していた古いブランチ)
                            :   何も問題がなければ、成功する。ブランチがきえる。
                            :   warning: deleting branch 'emergency_stop' that has been merged to
                                'refs/remotes/origin/emergency_stop', but not yet merged to HEAD.

                            :   上記の警告は、HEAD(現在選択中のブランチ)が、消そうとしているリポジトリから（リモート上で）マージされているが、
                            :   ローカルのブランチにはその内容が反映されていない。という注意。前もってmainを最新の状態にすれば出なくなると思われる。


	「HEAD」は、現在のブランチを指し示すポインタ


-----------------------------------------------------------------------------------------------------------------------------
    (4) 新しく作業ブランチを作る。
-----------------------------------------------------------------------------------------------------------------------------
        ＜リモート上＞
        ・gitlab上でtop画面から、「※個のブランチ」を選択すると、ブランチ一覧画面にいくので、「新しいブランチ」ボタンを押すことで、
            新しいブランチを作れる。（ブランチ元になるブランチを選択できる）
        ＜ローカル上＞
        ・git fetch origin    : リモートリポジトリの最新の履歴を取得（新しいブランチの情報もこれでダウンロードされる）
        ・git switch -c (新しいブランチ名) origin/(リモートブランチ名) :で、リモートブランチが新たに作られ、そこに切り替えられる。

        →VSCODE上でも新しいブランチが選択された状態になっている。
        ここから作業を開始できる。

-----------------------------------------------------------------------------------------------------------------------------
    (5)古いバージョンの取得
-----------------------------------------------------------------------------------------------------------------------------
        ＜ローカル＞
        ・git fetch originで、すべての履歴を取得できる。
        ・git log ：すべてのコミットが表示される。
            ・たくさん表示がある場合にはページャーが効いた状態になり、f:次ページ b:前ページ q:終了の操作になる。
            ・各コミットにはハッシュがついており、望むバージョンのハッシュを控える。コピーする。
        ・git checkout ハッシュ : 指示したハッシュのバージョンのコード状態となる。
                                
                                そのときに、どのブランチにも属さない(detachedHEADという特別なHEAD(ポインタ))状態になり、
                                例えばそこでコミットしてしまっても、どこのブランチにも属さない変更となる。
                                変更が必要なときは、新しいブランチを作成し、そこにマージするようにする。
                                (具体的なやりかた：
                                    git checkout -b 新しいブランチ名    :  そのバージョン状態で新しいブランチができ、チェックアウトする。
                                    この後は、普通にこのブランチでの作業となる。古いバージョン上での作業になるので、マージには気をつける。
                                )
                                
        ・元に戻したいとき
            git switch （同じブランチ名）   ：で、当該ブランチの最新状態にできる。

-----------------------------------------------------------------------------------------------------------------------------
    (6) ファイル管理から外す
-----------------------------------------------------------------------------------------------------------------------------
        .gitignoreファイルをルートにおいておくと、そこに定義されたファイルを管理から除外する。/foldername でフォルダごとgitからはずす。
        作業の途中からgitignoreを設定した場合、反映されないことがあるのでその場合は
        git rm -r --cached . 
        を実行する。

-----------------------------------------------------------------------------------------------------------------------------
    (7) リポジトリのフォーク
-----------------------------------------------------------------------------------------------------------------------------
フォークは、マスターのリポジトリはそのままに、別のリポジトリを新たに作成し、フォーク時点でのコピーを作る。
フォークした側は、マスターとは関係なく（これをオリジナルとして普通に使える。
コミット、プッシュしてもマスターに変更はかからない。
マスターは自身のフォークとの紐付けをしているので、
フォーク側での変更（改良やバージョンアプなど）をしたものをプルリクエストをすることで、同期ができる。

    ・GitLabにて右上の「Fork」ボタンをおす。
    ・プロジェクト名にはフォーク先のリポジトリ名とする。※すでに存在しているものはNG：エラーになる。
    ・プロジェクトURLのネームスペース選択ではフォーク先のリポジトリをおくディレクトリ？を指定する。
    ・プレジェクトslugは、リモートURLをユニークするため、URLに付加される名前。デフォルトで適当な名前がつけられているのでそのまま使ってもいいし、自分でつけてもよい。
        ★リポジトリ名とは関係ない。
        ★同じネームスペース（同列に複数リポジトリがあるフォルダ）内部でユニークである必要がある。
        ★例
            プロジェクト名「DShockBoard_CPUDC」
            プロジェクトのURL「http://git.discojpn.com/」
            ネームスペース「dicer_e2/firmware/rx111/dshockboard」
            プロジェクトslug「d-shock-board-cpudc」 ※
                          ↓
                ・作成されるリポジトリ「dicer_e2/firmware/rx111/dshockboard/DShockBoard_CPUDC」
                ・URL「http://git.discojpn.com/dicer_e2/firmware/rx111/dshockboard/d-shock-board-cpudc.git」

        となる。

    これ移行は通常の操作と同じで、フォーク先で行った変更をマスターへ同期したい場合は、「プルリクエスト」を行う。




-----------------------------------------------------------------------------------------------------------------------------
参考：	git が管理するツリー
https://git-scm.com/book/ja/v2/Git-%E3%81%AE%E3%81%95%E3%81%BE%E3%81%96%E3%81%BE%E3%81%AA%E3%83%84%E3%83%BC%E3%83%AB-%E3%83%AA%E3%82%BB%E3%83%83%E3%83%88%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E8%A9%B3%E8%AA%AC
-----------------------------------------------------------------------------------------------------------------------------
(1)HEAD	: commit したらここに登録される。

							   HEAD：ブランチが指し示すポインタ。基本的に最新に
								|
	 ver1  <--	ver2	<----  ver3				:コミットした回数分、履歴が増えていき、HEADは最新版を指し示す。

(2)Index: add したらここに登録される。（ステージングエリアと呼ばれる）
	   ver4のファイル
			 |
			add
 
(3)Working Dir 	:作業ディレクトリ
		現在編集している場所。


	

